%% Description:
% This script accepts as input a file of data generated by maneuvering.m, and uses
% the data to compute state estimates using an IMM, largely taken from
% Section 11.6 of Bar-Shalom's "Estimation with Applications to Tracking and Navigation".
% Note that this script uses the notation "M" in place of what Bar-Shalom
% calls "P" since we use P for the Markov transition matrix.


%% tweakable system parameters
infile = 'data/test.mat';       % file of input data (target trajectories, system parameters)
outfile = 'data/test_imm.mat';  % file where results of IMM get saved

%% load data from file, do some renaming of variables, free up some memory
load(infile);
p=size(F0,1);                   % get dimensions of state and process noise vectors
x=x_imm;
z=z_imm;
seqLength = size(XX,2);
[~,N2,numSims]=size(x);
clear XX YY x_imm z_imm

%% non-tweakable parameters and intermediate variables
H=[1 zeros(1,p-1)];              % matrix for system model (observation eq)
numModes = size(P,1);               % number of modes (probably 2 for this project)

%% allocate space and initialize
x_hat_imm=zeros(p,N2);              % allocate space for x_hat_imm (mixed estimate)
x_hat_pred_imm=zeros(p,N2);         % allocate space for x_hat_pred_imm (mixed prediction)
x_hat=zeros(p,numModes,N2);         % allocate space for x_hat (model estimates), and implictly initialize [zero mean assumption]
x_hat_pred=zeros(p,numModes,N2);    % allocate space for x_hat_pred (model estimates)
sampleM=zeros(p,p,N2);              % allocate space for sampleM (sample mean squared error)
sampleM_pred=zeros(p,p,N2);         % allocate space for sampleM_pred (sample predicted mean squared error)
mu=zeros(numModes,N2);              % allocate space for mixing weights
mu(:,1)=ones(numModes,1)/numModes;  % initialize weights (equally likely to be in either state at start)
M=zeros(p,p,numModes,N2);           % allocate space for M (MSE covariance matrix), and initialize
M(:,:,1,1)=eye(p);                  % good mode init
M(:,:,1,2)=eye(p);                  % bad mode init
M0 = zeros(p,p,numModes);           % allocate space for mixed state covariance matrix
Lambda=zeros(numModes,1);           % allocate space for likelihoods
SqErr_IMM = zeros(N2, numSims);       % allocate space for per-sample and per-realization squared error

%% main loop
fprintf('Processing...')
for k=1:numSims
    for n=2:N2
        
        % interaction / mixing
        c_bar=P'*mu(:,n-1);                     % normalizing factors for mixing probabilities (11.6.6-8)
        MU = diag(mu(:,n-1))*P*diag(1./c_bar);  % mixing probabilities (11.6.6-7)
        X_hat_0 = x_hat(:,:,n-1)*MU;            % mixed initial condition (11.6.6-9)
        
        for j=1:numModes
            % compute mixed state covariance M0 for each filter (11.6.6-10)
            M0(:,:,j)=sum(M(:,:,:,n-1).*reshape(MU(:,j),1,1,[]),3);
            e=x_hat(:,:,n-1)-repmat(X_hat_0(:,j),1,numModes);
            for i = 1:numModes
                M0(:,:,j) = M0(:,:,j) + MU(i,j)*e(:,i)*e(:,i)';
            end
            
            % compute filtered estimate/prediction and updated M for each model
            if j==1 % model 1 (good channel)
                F = F0;
                M_pred=F*M0(:,:,1)*F'+Q;
            elseif j==2 % model 2 (bad channel)
                F = F1;
                M_pred=F*M0(:,:,2)*F'+Q;
            else
                error('Invalid model number.');
            end
            x_hat_pred(:,j,n)=F*X_hat_0(:,j);        % state prediction
            z_hat_pred = H*x_hat_pred(:,j,n);        % output prediction
            S=(H*M_pred*H'+R);                       % S matrix from KF
            S=(S+S')/2;                              % S should be symmetric, but make it so in ill-conditioned cases 
            K=M_pred*H'/S;                           % Kalman gain
            x_hat(:,j,n)=x_hat_pred(:,j,n)+K*(z(:,n,k)-H*x_hat_pred(:,j,n));  % new estimate
            %M(:,:,j,n)=(eye(p)-K*H)*M_pred;         % update covariance
            M(:,:,j,n)=(eye(p)-K*H)*M_pred*(eye(p)-K*H)'+K*R*K';  % same as above... more computationally expensive, but guarantees symmetry when things are ill-conditioned
            Lambda(j) = mvnpdf([real(z(:,n,k)) imag(z(:,n,k))],[real(z_hat_pred) imag(z_hat_pred)],S*eye(2)/2); % compute likelihood functions (11.6.6-11)
        end
        
        % mixing probability calculation, compute final output state estimate
        Lambda(Lambda<eps)=eps;                           % numerical hack for small Lambdas
        mu(:,n)=(Lambda.*c_bar)/(Lambda'*c_bar);          % update mode probabilities (11.6.6-15)
        x_hat_imm(:,n)=x_hat(:,:,n)*mu(:,n);              % compute combined estimate (11.6.6-17)
        x_hat_pred_imm(:,n)=x_hat_pred(:,:,n)*mu(:,n-1);  % compute combined prediction
        
        %% compute sample mean square error (i.e., actual, not theoretical)
        e=x_hat_imm(:,n)-x(:,n,k);               % error between estimate and true state
        e_pred=x_hat_pred_imm(:,n)-x(:,n,k);     % error between prediction and true state
        sampleM(:,:,n)=sampleM(:,:,n)+e*e'/numSims;  % sample MSE
        temp=e_pred*e_pred';
        sampleM_pred(:,:,n)=sampleM_pred(:,:,n)+e_pred*e_pred'/numSims;  % sample prediction MSE
        SqErr_IMM(n,k)=temp(1,1);            % save prediction squared error
        
    end
    
    % report percentage complete to user
    if ismember(k,round(linspace(0,numSims,11)))
        fprintf([num2str(round(k/numSims*100)) '%%...'])
    end
    
end
disp(' '); % newline

%% report performance of IMM
disp(['Averaged over ' num2str(numSims) ' realizations with ' num2str(N2-seqLength-1) ' samples each, the mean'])
disp('squared prediction error (x and y coords combined) is as follows:')
disp(' ')
disp(['IMM: ' num2str(mean(mean(SqErr_IMM(seqLength+2:end,:))))])

%% save results
save(outfile,'SqErr_IMM','x_hat_pred_imm','mu')
